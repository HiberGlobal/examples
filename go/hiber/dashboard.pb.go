// Code generated by protoc-gen-go.
// source: dashboard.proto
// DO NOT EDIT!

package hiber

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Get the data for the dashboard. This includes map data, message count and relevant status events.
// MapSelection is used for the map data, as used in the MapService.
// ModemMessageSelection is used to filter the messages used for the count by day.
type DashboardRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	// * for ground stations and map blocks
	Selection *MapSelection `protobuf:"bytes,2,opt,name=selection" json:"selection,omitempty"`
	// * for modem messages
	MessageCountSelection *ModemMessageSelection `protobuf:"bytes,3,opt,name=message_count_selection,json=messageCountSelection" json:"message_count_selection,omitempty"`
	// * for events, only used when any value is set
	EventSelection *EventSelection `protobuf:"bytes,4,opt,name=event_selection,json=eventSelection" json:"event_selection,omitempty"`
}

func (m *DashboardRequest) Reset()                    { *m = DashboardRequest{} }
func (m *DashboardRequest) String() string            { return proto.CompactTextString(m) }
func (*DashboardRequest) ProtoMessage()               {}
func (*DashboardRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *DashboardRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *DashboardRequest) GetSelection() *MapSelection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *DashboardRequest) GetMessageCountSelection() *ModemMessageSelection {
	if m != nil {
		return m.MessageCountSelection
	}
	return nil
}

func (m *DashboardRequest) GetEventSelection() *EventSelection {
	if m != nil {
		return m.EventSelection
	}
	return nil
}

type DashboardRequest_Response struct {
	// list of ground stations and their location
	GroundStations []*GroundStation `protobuf:"bytes,1,rep,name=ground_stations,json=groundStations" json:"ground_stations,omitempty"`
	// list of map blocks and their modem count, for density map
	MapBlocks          []*MapBlock      `protobuf:"bytes,2,rep,name=map_blocks,json=mapBlocks" json:"map_blocks,omitempty"`
	MessageCountPerDay map[string]int32 `protobuf:"bytes,3,rep,name=message_count_per_day,json=messageCountPerDay" json:"message_count_per_day,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// counts of the number of modems with warning and errors
	ModemWarningCount int32 `protobuf:"varint,4,opt,name=modem_warning_count,json=modemWarningCount" json:"modem_warning_count,omitempty"`
	ModemErrorCount   int32 `protobuf:"varint,5,opt,name=modem_error_count,json=modemErrorCount" json:"modem_error_count,omitempty"`
	// returns the latest 20 matching events, or an empty list if the event selection wasn't set
	Events  []*Event          `protobuf:"bytes,6,rep,name=events" json:"events,omitempty"`
	Request *DashboardRequest `protobuf:"bytes,7,opt,name=request" json:"request,omitempty"`
}

func (m *DashboardRequest_Response) Reset()                    { *m = DashboardRequest_Response{} }
func (m *DashboardRequest_Response) String() string            { return proto.CompactTextString(m) }
func (*DashboardRequest_Response) ProtoMessage()               {}
func (*DashboardRequest_Response) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

func (m *DashboardRequest_Response) GetGroundStations() []*GroundStation {
	if m != nil {
		return m.GroundStations
	}
	return nil
}

func (m *DashboardRequest_Response) GetMapBlocks() []*MapBlock {
	if m != nil {
		return m.MapBlocks
	}
	return nil
}

func (m *DashboardRequest_Response) GetMessageCountPerDay() map[string]int32 {
	if m != nil {
		return m.MessageCountPerDay
	}
	return nil
}

func (m *DashboardRequest_Response) GetModemWarningCount() int32 {
	if m != nil {
		return m.ModemWarningCount
	}
	return 0
}

func (m *DashboardRequest_Response) GetModemErrorCount() int32 {
	if m != nil {
		return m.ModemErrorCount
	}
	return 0
}

func (m *DashboardRequest_Response) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *DashboardRequest_Response) GetRequest() *DashboardRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterType((*DashboardRequest)(nil), "hiber.dashboard.DashboardRequest")
	proto.RegisterType((*DashboardRequest_Response)(nil), "hiber.dashboard.DashboardRequest.Response")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DashboardService service

type DashboardServiceClient interface {
	Dashboard(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardRequest_Response, error)
}

type dashboardServiceClient struct {
	cc *grpc.ClientConn
}

func NewDashboardServiceClient(cc *grpc.ClientConn) DashboardServiceClient {
	return &dashboardServiceClient{cc}
}

func (c *dashboardServiceClient) Dashboard(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardRequest_Response, error) {
	out := new(DashboardRequest_Response)
	err := grpc.Invoke(ctx, "/hiber.dashboard.DashboardService/Dashboard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DashboardService service

type DashboardServiceServer interface {
	Dashboard(context.Context, *DashboardRequest) (*DashboardRequest_Response, error)
}

func RegisterDashboardServiceServer(s *grpc.Server, srv DashboardServiceServer) {
	s.RegisterService(&_DashboardService_serviceDesc, srv)
}

func _DashboardService_Dashboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DashboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).Dashboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hiber.dashboard.DashboardService/Dashboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).Dashboard(ctx, req.(*DashboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DashboardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hiber.dashboard.DashboardService",
	HandlerType: (*DashboardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dashboard",
			Handler:    _DashboardService_Dashboard_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dashboard.proto",
}

func init() { proto.RegisterFile("dashboard.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 489 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x53, 0xbf, 0x6f, 0x9b, 0x40,
	0x14, 0xae, 0xed, 0xd8, 0xae, 0x9f, 0xab, 0x38, 0xbd, 0x34, 0x32, 0xa2, 0x43, 0xdd, 0x4c, 0x56,
	0x06, 0x06, 0x57, 0x95, 0xa2, 0x76, 0x8a, 0x6b, 0xab, 0x93, 0xa5, 0xe8, 0x3c, 0x54, 0xf2, 0x82,
	0x0e, 0x78, 0x22, 0x28, 0xc0, 0xd1, 0x3b, 0x70, 0xe5, 0xbd, 0x63, 0xff, 0xe8, 0x8a, 0x77, 0x60,
	0x70, 0xa2, 0x2a, 0x5d, 0x10, 0xef, 0x7d, 0x3f, 0x8e, 0xef, 0x3d, 0x0e, 0x26, 0x81, 0xd0, 0x0f,
	0x9e, 0x14, 0x2a, 0x70, 0x32, 0x25, 0x73, 0xc9, 0x26, 0x0f, 0x91, 0x87, 0xca, 0x39, 0xb6, 0xed,
	0x51, 0x22, 0x32, 0x83, 0xd9, 0xe3, 0x44, 0x06, 0x98, 0xd4, 0x05, 0xee, 0x31, 0xcd, 0x4d, 0x71,
	0xfd, 0x67, 0x00, 0x17, 0xab, 0x5a, 0xc2, 0xf1, 0x67, 0x81, 0x3a, 0x67, 0x16, 0x0c, 0x85, 0xef,
	0xcb, 0x22, 0xcd, 0xad, 0xce, 0xac, 0x33, 0x1f, 0xf1, 0xba, 0x64, 0x9f, 0x61, 0xa4, 0x31, 0x46,
	0x3f, 0x8f, 0x64, 0x6a, 0x75, 0x67, 0x9d, 0xf9, 0x78, 0x31, 0x75, 0xcc, 0xc1, 0xe5, 0x69, 0x1b,
	0x91, 0x6d, 0x6b, 0x98, 0x37, 0x4c, 0xb6, 0x83, 0x69, 0x82, 0x5a, 0x8b, 0x10, 0x5d, 0xf2, 0x71,
	0x1b, 0x93, 0x1e, 0x99, 0x5c, 0xd7, 0x26, 0xf4, 0x9d, 0x9b, 0xf2, 0xb9, 0x31, 0x82, 0xc6, 0xef,
	0xaa, 0xb2, 0xf8, 0x56, 0x3a, 0x1c, 0xdb, 0x6c, 0x05, 0x13, 0x0a, 0xd4, 0xf2, 0x3c, 0x23, 0xcf,
	0xf7, 0x95, 0xa7, 0x89, 0xbb, 0x2e, 0x9f, 0x8d, 0xd9, 0x39, 0x9e, 0xd4, 0xf6, 0xef, 0x33, 0x78,
	0xcd, 0x51, 0x67, 0x32, 0xd5, 0xc8, 0xee, 0x60, 0x12, 0x2a, 0x59, 0xa4, 0x81, 0xab, 0x73, 0x51,
	0xc2, 0xda, 0xea, 0xcc, 0x7a, 0xf3, 0xf1, 0xc2, 0x6a, 0x65, 0xfd, 0x4e, 0x8c, 0xad, 0x21, 0xf0,
	0xf3, 0xb0, 0x5d, 0x6a, 0xb6, 0x00, 0x48, 0x44, 0xe6, 0x7a, 0xb1, 0xf4, 0x1f, 0xb5, 0xd5, 0x25,
	0xf5, 0xe5, 0xe9, 0xa4, 0x96, 0x25, 0xc6, 0xcb, 0x2d, 0xd1, 0x9b, 0x66, 0x05, 0x5c, 0x9d, 0x4e,
	0x29, 0x43, 0xe5, 0x06, 0xe2, 0x60, 0xf5, 0x48, 0xbe, 0x74, 0x9e, 0x6c, 0xd8, 0x79, 0xba, 0x38,
	0xa7, 0x4e, 0xe0, 0x6c, 0x5a, 0xa3, 0xba, 0x47, 0xb5, 0x12, 0x87, 0x75, 0x9a, 0xab, 0x03, 0x67,
	0xc9, 0x33, 0x80, 0x39, 0x70, 0x49, 0x63, 0x77, 0x7f, 0x09, 0x95, 0x46, 0x69, 0x68, 0x0e, 0xa7,
	0x21, 0xf6, 0xf9, 0x5b, 0x82, 0x7e, 0x18, 0x84, 0x54, 0xec, 0x06, 0x4c, 0xd3, 0x45, 0xa5, 0xa4,
	0xaa, 0xd8, 0x7d, 0x62, 0x4f, 0x08, 0x58, 0x97, 0xfd, 0x9a, 0x3b, 0xa0, 0x41, 0x6b, 0x6b, 0x40,
	0x19, 0xd8, 0xf3, 0x9d, 0xf0, 0x8a, 0xc1, 0xbe, 0xc2, 0x50, 0x99, 0x1c, 0xd6, 0x90, 0x16, 0xf8,
	0xf1, 0xc5, 0xc0, 0xbc, 0x56, 0xd8, 0x6b, 0x98, 0xfe, 0x23, 0x33, 0xbb, 0x80, 0xde, 0x23, 0x1e,
	0xaa, 0x3f, 0xb9, 0x7c, 0x65, 0xef, 0xa0, 0xbf, 0x17, 0x71, 0x81, 0xf4, 0x07, 0xf7, 0xb9, 0x29,
	0xbe, 0x74, 0x6f, 0x3b, 0x8b, 0xb4, 0x75, 0x1b, 0xb6, 0xa8, 0xf6, 0x91, 0x8f, 0x6c, 0x07, 0xa3,
	0x63, 0x8f, 0xbd, 0xfc, 0x4d, 0xf6, 0xcd, 0xff, 0xef, 0x69, 0x79, 0x0b, 0x1f, 0xc2, 0x58, 0x7a,
	0x22, 0xae, 0x34, 0x22, 0x8b, 0x9c, 0x50, 0x65, 0x7e, 0x23, 0x5e, 0xbe, 0x39, 0xaa, 0xef, 0xb2,
	0xe8, 0xfe, 0xd5, 0xae, 0x4f, 0x4c, 0x6f, 0x40, 0xf7, 0xf7, 0xd3, 0xdf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xcf, 0x13, 0x86, 0x26, 0x08, 0x04, 0x00, 0x00,
}
