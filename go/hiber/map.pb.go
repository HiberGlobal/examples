// Code generated by protoc-gen-go.
// source: map.proto
// DO NOT EDIT!

package hiber

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Selection object for map data. Filter modems on the map by id, (child)account.
// Also, filter the map data by level and area restriction, to only display a small area at a detailed map level,
// for example
type MapSelection struct {
	Modems        *Filter_Modems                `protobuf:"bytes,1,opt,name=modems" json:"modems,omitempty"`
	ChildAccounts *Filter_ChildAccounts         `protobuf:"bytes,2,opt,name=child_accounts,json=childAccounts" json:"child_accounts,omitempty"`
	Level         int32                         `protobuf:"varint,3,opt,name=level" json:"level,omitempty"`
	Area          *MapSelection_AreaRestriction `protobuf:"bytes,4,opt,name=area" json:"area,omitempty"`
}

func (m *MapSelection) Reset()                    { *m = MapSelection{} }
func (m *MapSelection) String() string            { return proto.CompactTextString(m) }
func (*MapSelection) ProtoMessage()               {}
func (*MapSelection) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *MapSelection) GetModems() *Filter_Modems {
	if m != nil {
		return m.Modems
	}
	return nil
}

func (m *MapSelection) GetChildAccounts() *Filter_ChildAccounts {
	if m != nil {
		return m.ChildAccounts
	}
	return nil
}

func (m *MapSelection) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MapSelection) GetArea() *MapSelection_AreaRestriction {
	if m != nil {
		return m.Area
	}
	return nil
}

type MapSelection_AreaRestriction struct {
	BottomLeft *Location `protobuf:"bytes,1,opt,name=bottom_left,json=bottomLeft" json:"bottom_left,omitempty"`
	TopRight   *Location `protobuf:"bytes,2,opt,name=top_right,json=topRight" json:"top_right,omitempty"`
}

func (m *MapSelection_AreaRestriction) Reset()                    { *m = MapSelection_AreaRestriction{} }
func (m *MapSelection_AreaRestriction) String() string            { return proto.CompactTextString(m) }
func (*MapSelection_AreaRestriction) ProtoMessage()               {}
func (*MapSelection_AreaRestriction) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0, 0} }

func (m *MapSelection_AreaRestriction) GetBottomLeft() *Location {
	if m != nil {
		return m.BottomLeft
	}
	return nil
}

func (m *MapSelection_AreaRestriction) GetTopRight() *Location {
	if m != nil {
		return m.TopRight
	}
	return nil
}

// The location of ground stations that receive the data sent from the satellite(s).
// Currently, ground station is just a marker on the map.
type GroundStation struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
}

func (m *GroundStation) Reset()                    { *m = GroundStation{} }
func (m *GroundStation) String() string            { return proto.CompactTextString(m) }
func (*GroundStation) ProtoMessage()               {}
func (*GroundStation) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *GroundStation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// Map block that specifies a modem count in a specific area, bounded by a latitude / longitude 'square' (not really a
// quare, since the earth is not flat).
// Also contains an error count and percentage, which signifies any problems in the area.
// Note that the bloack's area is specified by the selected map level, which the most course map level defined as
// squares of 20 by 20 degrees latitude/longitude.s
type MapBlock struct {
	Area            *Area   `protobuf:"bytes,1,opt,name=area" json:"area,omitempty"`
	ModemCount      int32   `protobuf:"varint,2,opt,name=modem_count,json=modemCount" json:"modem_count,omitempty"`
	ErrorCount      int32   `protobuf:"varint,3,opt,name=error_count,json=errorCount" json:"error_count,omitempty"`
	ErrorPercentage float32 `protobuf:"fixed32,4,opt,name=error_percentage,json=errorPercentage" json:"error_percentage,omitempty"`
}

func (m *MapBlock) Reset()                    { *m = MapBlock{} }
func (m *MapBlock) String() string            { return proto.CompactTextString(m) }
func (*MapBlock) ProtoMessage()               {}
func (*MapBlock) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *MapBlock) GetArea() *Area {
	if m != nil {
		return m.Area
	}
	return nil
}

func (m *MapBlock) GetModemCount() int32 {
	if m != nil {
		return m.ModemCount
	}
	return 0
}

func (m *MapBlock) GetErrorCount() int32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *MapBlock) GetErrorPercentage() float32 {
	if m != nil {
		return m.ErrorPercentage
	}
	return 0
}

type MapRequest struct {
	Account   string        `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Selection *MapSelection `protobuf:"bytes,2,opt,name=selection" json:"selection,omitempty"`
}

func (m *MapRequest) Reset()                    { *m = MapRequest{} }
func (m *MapRequest) String() string            { return proto.CompactTextString(m) }
func (*MapRequest) ProtoMessage()               {}
func (*MapRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *MapRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *MapRequest) GetSelection() *MapSelection {
	if m != nil {
		return m.Selection
	}
	return nil
}

type MapRequest_Response struct {
	GroundStations []*GroundStation `protobuf:"bytes,1,rep,name=ground_stations,json=groundStations" json:"ground_stations,omitempty"`
	MapBlocks      []*MapBlock      `protobuf:"bytes,2,rep,name=map_blocks,json=mapBlocks" json:"map_blocks,omitempty"`
	Request        *MapRequest      `protobuf:"bytes,4,opt,name=request" json:"request,omitempty"`
}

func (m *MapRequest_Response) Reset()                    { *m = MapRequest_Response{} }
func (m *MapRequest_Response) String() string            { return proto.CompactTextString(m) }
func (*MapRequest_Response) ProtoMessage()               {}
func (*MapRequest_Response) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3, 0} }

func (m *MapRequest_Response) GetGroundStations() []*GroundStation {
	if m != nil {
		return m.GroundStations
	}
	return nil
}

func (m *MapRequest_Response) GetMapBlocks() []*MapBlock {
	if m != nil {
		return m.MapBlocks
	}
	return nil
}

func (m *MapRequest_Response) GetRequest() *MapRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterType((*MapSelection)(nil), "hiber.map.MapSelection")
	proto.RegisterType((*MapSelection_AreaRestriction)(nil), "hiber.map.MapSelection.AreaRestriction")
	proto.RegisterType((*GroundStation)(nil), "hiber.map.GroundStation")
	proto.RegisterType((*MapBlock)(nil), "hiber.map.MapBlock")
	proto.RegisterType((*MapRequest)(nil), "hiber.map.MapRequest")
	proto.RegisterType((*MapRequest_Response)(nil), "hiber.map.MapRequest.Response")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MapService service

type MapServiceClient interface {
	Map(ctx context.Context, in *MapRequest, opts ...grpc.CallOption) (*MapRequest_Response, error)
}

type mapServiceClient struct {
	cc *grpc.ClientConn
}

func NewMapServiceClient(cc *grpc.ClientConn) MapServiceClient {
	return &mapServiceClient{cc}
}

func (c *mapServiceClient) Map(ctx context.Context, in *MapRequest, opts ...grpc.CallOption) (*MapRequest_Response, error) {
	out := new(MapRequest_Response)
	err := grpc.Invoke(ctx, "/hiber.map.MapService/Map", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MapService service

type MapServiceServer interface {
	Map(context.Context, *MapRequest) (*MapRequest_Response, error)
}

func RegisterMapServiceServer(s *grpc.Server, srv MapServiceServer) {
	s.RegisterService(&_MapService_serviceDesc, srv)
}

func _MapService_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServiceServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hiber.map.MapService/Map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServiceServer).Map(ctx, req.(*MapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MapService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hiber.map.MapService",
	HandlerType: (*MapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Map",
			Handler:    _MapService_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "map.proto",
}

func init() { proto.RegisterFile("map.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 515 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x93, 0xc1, 0x6e, 0x13, 0x31,
	0x10, 0x86, 0x49, 0xda, 0xa4, 0xc9, 0x84, 0x36, 0xc8, 0x14, 0xb1, 0x04, 0x89, 0x56, 0xb9, 0x10,
	0x44, 0xb4, 0xa0, 0x20, 0x4e, 0xf4, 0x92, 0x54, 0x02, 0x09, 0x75, 0xa5, 0xca, 0xb9, 0x71, 0x59,
	0x79, 0x37, 0xd3, 0xcd, 0x8a, 0xdd, 0xd8, 0xb5, 0x9d, 0x3e, 0x08, 0x27, 0x9e, 0x83, 0x87, 0xe0,
	0xb9, 0x90, 0xc7, 0x4e, 0x48, 0xa0, 0xbd, 0x65, 0x66, 0xbe, 0xdf, 0x99, 0xff, 0xb7, 0x17, 0xba,
	0xb5, 0x50, 0xb1, 0xd2, 0xd2, 0x4a, 0xd6, 0x5d, 0x96, 0x19, 0xea, 0xb8, 0x16, 0x6a, 0x00, 0x99,
	0x30, 0xe8, 0xdb, 0xc3, 0xdf, 0x4d, 0x78, 0x9c, 0x08, 0x35, 0xc7, 0x0a, 0x73, 0x5b, 0xca, 0x15,
	0x1b, 0x43, 0xbb, 0x96, 0x0b, 0xac, 0x4d, 0xd4, 0x38, 0x6f, 0x8c, 0x7a, 0x93, 0xd3, 0xd8, 0x0b,
	0x3f, 0x97, 0x95, 0x45, 0x1d, 0x27, 0x34, 0xe3, 0x81, 0x61, 0x33, 0x38, 0xc9, 0x97, 0x65, 0xb5,
	0x48, 0x45, 0x9e, 0xcb, 0xf5, 0xca, 0x9a, 0xa8, 0x49, 0xaa, 0x97, 0xfb, 0xaa, 0x4b, 0xc7, 0x4c,
	0x03, 0xc2, 0x8f, 0xf3, 0xdd, 0x92, 0x9d, 0x42, 0xab, 0xc2, 0x3b, 0xac, 0xa2, 0x83, 0xf3, 0xc6,
	0xa8, 0xc5, 0x7d, 0xc1, 0x3e, 0xc1, 0xa1, 0xd0, 0x28, 0xa2, 0x43, 0x3a, 0xef, 0x75, 0xbc, 0x5d,
	0x3f, 0xde, 0x5d, 0x37, 0x9e, 0x6a, 0x14, 0x1c, 0x8d, 0xd5, 0x25, 0xd5, 0x9c, 0x44, 0x83, 0x5b,
	0xe8, 0xff, 0x33, 0x60, 0xef, 0xa1, 0x97, 0x49, 0x6b, 0x65, 0x9d, 0x56, 0x78, 0x63, 0x83, 0xb9,
	0x7e, 0x38, 0xf6, 0x4a, 0xe6, 0x82, 0xe4, 0xe0, 0x99, 0x2b, 0xbc, 0xb1, 0x6c, 0x0c, 0x5d, 0x2b,
	0x55, 0xaa, 0xcb, 0x62, 0x69, 0x83, 0xad, 0xff, 0xf8, 0x8e, 0x95, 0x8a, 0x3b, 0x60, 0x78, 0x01,
	0xc7, 0x5f, 0xb4, 0x5c, 0xaf, 0x16, 0x73, 0x4b, 0x23, 0xf6, 0x16, 0x3a, 0x55, 0xc0, 0x1e, 0xfa,
	0xb7, 0x2d, 0x30, 0xfc, 0xd9, 0x80, 0x4e, 0x22, 0xd4, 0xac, 0x92, 0xf9, 0x77, 0x76, 0x16, 0xac,
	0x7b, 0x55, 0x2f, 0xa8, 0xc8, 0x10, 0x0d, 0xd8, 0x19, 0xf4, 0x28, 0xff, 0x94, 0x12, 0xa4, 0xdd,
	0x5a, 0x1c, 0xa8, 0x75, 0xe9, 0x3a, 0x0e, 0x40, 0xad, 0xa5, 0x0e, 0x80, 0x0f, 0x16, 0xa8, 0xe5,
	0x81, 0x37, 0xf0, 0xc4, 0x03, 0x0a, 0x75, 0x8e, 0x2b, 0x2b, 0x0a, 0xa4, 0xa4, 0x9b, 0xbc, 0x4f,
	0xfd, 0xeb, 0x6d, 0x7b, 0xf8, 0xa3, 0x09, 0x90, 0x08, 0xc5, 0xf1, 0x76, 0x8d, 0xc6, 0xb2, 0x08,
	0x8e, 0xc2, 0x5d, 0xd3, 0x7e, 0x5d, 0xbe, 0x29, 0xd9, 0x47, 0xe8, 0x9a, 0xcd, 0xbd, 0x84, 0xbc,
	0x9e, 0x3f, 0x70, 0x6d, 0xfc, 0x2f, 0x39, 0xf8, 0xd5, 0x80, 0x0e, 0x47, 0xa3, 0xe4, 0xca, 0x20,
	0x9b, 0x42, 0xbf, 0xa0, 0x14, 0x53, 0xe3, 0x63, 0x74, 0xcf, 0xf0, 0x60, 0xd4, 0x9b, 0x44, 0x3b,
	0x27, 0xed, 0xe5, 0xcc, 0x4f, 0x8a, 0xdd, 0xd2, 0xb0, 0x09, 0x40, 0x2d, 0x54, 0x9a, 0xb9, 0x28,
	0xdd, 0x73, 0x74, 0xea, 0xa7, 0xfb, 0x7b, 0x50, 0xcc, 0xdc, 0x7d, 0x1c, 0xf4, 0xcb, 0xb0, 0x77,
	0x70, 0xa4, 0xbd, 0xbf, 0xf0, 0xde, 0x9e, 0xed, 0x0b, 0x82, 0x79, 0xbe, 0xa1, 0x26, 0x5f, 0x29,
	0x93, 0x39, 0xea, 0xbb, 0x32, 0x47, 0x76, 0x01, 0x07, 0x89, 0x50, 0xec, 0x7e, 0xd1, 0xe0, 0xd5,
	0xbd, 0xed, 0x78, 0xe3, 0x79, 0x36, 0x86, 0x17, 0x45, 0x25, 0x33, 0x51, 0x05, 0x4e, 0xa8, 0x32,
	0x2e, 0xb4, 0xca, 0x9d, 0x60, 0xd6, 0x4e, 0x84, 0x9a, 0xaa, 0xf2, 0xfa, 0xd1, 0xb7, 0x16, 0x4d,
	0xb3, 0x36, 0x7d, 0xb7, 0x1f, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x14, 0xab, 0x9a, 0xdb,
	0x03, 0x00, 0x00,
}
