// Code generated by protoc-gen-go.
// source: base.proto
// DO NOT EDIT!

/*
Package hiber is a generated protocol buffer package.

It is generated from these files:
	base.proto
	currentuser.proto
	dashboard.proto
	event.proto
	map.proto
	modem.proto
	modem_claim.proto
	modem_transfer.proto
	organization.proto
	subscription.proto
	tag.proto
	testing.proto
	token.proto
	user.proto
	webhook.proto

It has these top-level messages:
	UpdateZeroableInt
	UpdateClearableString
	UpdateBoolean
	TimeRange
	Timestamp
	Date
	Location
	Area
	Pagination
	Filter
	CurrentUser
	CurrentUserRequest
	RequestAccessRequest
	CancelAccessRequestRequest
	DeleteCurrentUserRequest
	UpdateDefaultOrganizationRequest
	UpdateSettingsRequest
	DashboardRequest
	Event
	EventSelection
	ListEventsRequest
	EventStreamRequest
	MapSelection
	GroundStation
	MapBlock
	MapRequest
	Modem
	ModemSelection
	ModemMessage
	ModemMessageSelection
	GetModemRequest
	ListModemsRequest
	ListModemMessagesRequest
	MessageCountRequest
	RenameModemRequest
	UpdateModemTagsRequest
	UpdatePeripheralsRequest
	LicenseKeysRequest
	ModemClaim
	ModemClaimSelection
	ClaimModemRequest
	ListModemClaimsRequest
	AcceptModemClaimsRequest
	RejectModemClaimsRequest
	ModemTransfer
	ModemTransferReturnLine
	ModemTransferSelection
	TransferModemsRequest
	ListModemTransfersRequest
	CancelModemTransferRequest
	ReceivedModemTransferRequest
	NotReceivedModemTransferRequest
	PrepareModemForReturnRequest
	DeleteModemTransferReturnLinesRequest
	ListModemTransferReturnLinesRequest
	SendReturnRequest
	Organization
	OrganizationSelection
	GetOrganizationRequest
	UpdateOrganizationRequest
	OrganizationTreeRequest
	OrganizationTree
	ListChildOrganizationsRequest
	CreateOrganizationRequest
	DeleteOrganizationRequest
	DeleteOrganizationConfirmationRequest
	Tag
	TagSelection
	UpdateTagsForItem
	ListTagsRequest
	CreateTagRequest
	UpdateTagRequest
	DeleteTagRequest
	PushModemMessagesRequest
	Token
	TokenSelection
	ListTokensRequest
	CreateTokenRequest
	DeleteTokenRequest
	User
	UserSelection
	ListUsersRequest
	ListAccessRequestsRequest
	ApproveUserRequest
	RemoveUserRequest
	CreateUserRequest
	Webhook
	WebhookSelection
	WebhookCall
	WebhookHistorySelection
	ListWebhooksRequest
	WebhookHistoryRequest
	CreateWebhookRequest
	GetWebhookRequest
	EnableWebhookRequest
	DisableWebhookRequest
	UpdateWebhookFilterRequest
	UpdateWebhookRequest
	UpdateWebhookTagsRequest
	DeleteWebhookRequest
*/
package hiber

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Enum of api-accessible events.
// The event types in this enum have a protobuf implementation, and can be used, for example, in the
// api event stream and webhooks.
type EventType int32

const (
	EventType_DEFAULT                                EventType = 0
	EventType_WEBHOOK_CREATED                        EventType = 1
	EventType_WEBHOOK_UPDATED                        EventType = 2
	EventType_WEBHOOK_DELETED                        EventType = 3
	EventType_MODEM_LOCATION_UPDATED                 EventType = 4
	EventType_MODEM_MESSAGE_RECEIVED                 EventType = 5
	EventType_USER_ACCESS_REQUEST                    EventType = 8
	EventType_USER_ADDED                             EventType = 9
	EventType_USER_REMOVED                           EventType = 10
	EventType_WEBHOOK_FAILED                         EventType = 11
	EventType_ORGANIZATION_UPDATED                   EventType = 12
	EventType_MODEM_MESSAGE_SEQUENCE_SKIP            EventType = 13
	EventType_MODEM_MESSAGE_DELAYED                  EventType = 14
	EventType_MODEM_MESSAGE_CANNOT_BE_PARSED         EventType = 15
	EventType_MODEM_STALE                            EventType = 16
	EventType_MODEM_TRANSFER_STARTED                 EventType = 17
	EventType_MODEM_TRANSFER_RECEIVED                EventType = 18
	EventType_MODEM_TRANSFER_CANCELLED               EventType = 19
	EventType_MODEM_TRANSFER_NOT_RECEIVED            EventType = 20
	EventType_MODEM_TRANSFER_RETURN_TRANSFER_STARTED EventType = 21
	EventType_MODEM_CLAIM_CREATED                    EventType = 22
	EventType_MODEM_CLAIM_ACCEPTED                   EventType = 23
	EventType_MODEM_CLAIM_REFUSED                    EventType = 24
)

var EventType_name = map[int32]string{
	0:  "DEFAULT",
	1:  "WEBHOOK_CREATED",
	2:  "WEBHOOK_UPDATED",
	3:  "WEBHOOK_DELETED",
	4:  "MODEM_LOCATION_UPDATED",
	5:  "MODEM_MESSAGE_RECEIVED",
	8:  "USER_ACCESS_REQUEST",
	9:  "USER_ADDED",
	10: "USER_REMOVED",
	11: "WEBHOOK_FAILED",
	12: "ORGANIZATION_UPDATED",
	13: "MODEM_MESSAGE_SEQUENCE_SKIP",
	14: "MODEM_MESSAGE_DELAYED",
	15: "MODEM_MESSAGE_CANNOT_BE_PARSED",
	16: "MODEM_STALE",
	17: "MODEM_TRANSFER_STARTED",
	18: "MODEM_TRANSFER_RECEIVED",
	19: "MODEM_TRANSFER_CANCELLED",
	20: "MODEM_TRANSFER_NOT_RECEIVED",
	21: "MODEM_TRANSFER_RETURN_TRANSFER_STARTED",
	22: "MODEM_CLAIM_CREATED",
	23: "MODEM_CLAIM_ACCEPTED",
	24: "MODEM_CLAIM_REFUSED",
}
var EventType_value = map[string]int32{
	"DEFAULT":                                0,
	"WEBHOOK_CREATED":                        1,
	"WEBHOOK_UPDATED":                        2,
	"WEBHOOK_DELETED":                        3,
	"MODEM_LOCATION_UPDATED":                 4,
	"MODEM_MESSAGE_RECEIVED":                 5,
	"USER_ACCESS_REQUEST":                    8,
	"USER_ADDED":                             9,
	"USER_REMOVED":                           10,
	"WEBHOOK_FAILED":                         11,
	"ORGANIZATION_UPDATED":                   12,
	"MODEM_MESSAGE_SEQUENCE_SKIP":            13,
	"MODEM_MESSAGE_DELAYED":                  14,
	"MODEM_MESSAGE_CANNOT_BE_PARSED":         15,
	"MODEM_STALE":                            16,
	"MODEM_TRANSFER_STARTED":                 17,
	"MODEM_TRANSFER_RECEIVED":                18,
	"MODEM_TRANSFER_CANCELLED":               19,
	"MODEM_TRANSFER_NOT_RECEIVED":            20,
	"MODEM_TRANSFER_RETURN_TRANSFER_STARTED": 21,
	"MODEM_CLAIM_CREATED":                    22,
	"MODEM_CLAIM_ACCEPTED":                   23,
	"MODEM_CLAIM_REFUSED":                    24,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}
func (EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Health is an indicator for issues. It is used for modems and webhooks to give a quick indication of issues.
type Health int32

const (
	Health_OK      Health = 0
	Health_WARNING Health = 1
	Health_ERROR   Health = 2
)

var Health_name = map[int32]string{
	0: "OK",
	1: "WARNING",
	2: "ERROR",
}
var Health_value = map[string]int32{
	"OK":      0,
	"WARNING": 1,
	"ERROR":   2,
}

func (x Health) String() string {
	return proto.EnumName(Health_name, int32(x))
}
func (Health) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Update object for an int that can be set to 0.
// Since 0 is also the default value, we need to distinguish between an omitted value and setting the value to 0,
// in an update object.
//
// To use this to update, set a value and set updated to true
type UpdateZeroableInt struct {
	Updated bool   `protobuf:"varint,1,opt,name=updated" json:"updated,omitempty"`
	Value   uint32 `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *UpdateZeroableInt) Reset()                    { *m = UpdateZeroableInt{} }
func (m *UpdateZeroableInt) String() string            { return proto.CompactTextString(m) }
func (*UpdateZeroableInt) ProtoMessage()               {}
func (*UpdateZeroableInt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpdateZeroableInt) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

func (m *UpdateZeroableInt) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Update object for a string that can be empty.
// Since an empty string is also the default value, we need to distinguish between an omitted value and
// setting the value to an empty string, in an update object.
//
// To use this to update, set a value and set updated to true
type UpdateClearableString struct {
	Updated bool   `protobuf:"varint,1,opt,name=updated" json:"updated,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *UpdateClearableString) Reset()                    { *m = UpdateClearableString{} }
func (m *UpdateClearableString) String() string            { return proto.CompactTextString(m) }
func (*UpdateClearableString) ProtoMessage()               {}
func (*UpdateClearableString) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpdateClearableString) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

func (m *UpdateClearableString) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Update object for a boolean.
// Since false is the default value, we need to distinguish between an omitted value and setting the value to false,
// in an update object.
//
// To use this to update, set a value and set updated to true
type UpdateBoolean struct {
	Updated bool `protobuf:"varint,1,opt,name=updated" json:"updated,omitempty"`
	Value   bool `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *UpdateBoolean) Reset()                    { *m = UpdateBoolean{} }
func (m *UpdateBoolean) String() string            { return proto.CompactTextString(m) }
func (*UpdateBoolean) ProtoMessage()               {}
func (*UpdateBoolean) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpdateBoolean) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

func (m *UpdateBoolean) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// Period of time between two timestamps. Typically used for filtering.
type TimeRange struct {
	Start *Timestamp `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Timestamp `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *TimeRange) Reset()                    { *m = TimeRange{} }
func (m *TimeRange) String() string            { return proto.CompactTextString(m) }
func (*TimeRange) ProtoMessage()               {}
func (*TimeRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TimeRange) GetStart() *Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *TimeRange) GetEnd() *Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

// Timestamp type for convenience.
// Some clients are better at parsing Google's seconds/nanos based timestamp, while others prefer a text-based format.
// To accomodate this, this Timestamp type supports both.
// When used as API output, both the timestamp and textual fields will be set. The textual field has the commonly
// used ISO 8601 format (i.e. "2018-01-01T13:00:00Z").
// When used an API input, only one of the fields is needed, there is no need to set both. When both are set, the
// timestamp field will be used, the textual field will be discarded.
type Timestamp struct {
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Textual   string                     `protobuf:"bytes,4,opt,name=textual" json:"textual,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Timestamp) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Timestamp) GetTextual() string {
	if m != nil {
		return m.Textual
	}
	return ""
}

// Date type for convenience.
// Some clients are better at parsing year, month and day of month as separate fields, while others prefer a
// text-based format. To accomodate this, this Date type supports both.
// When used as API output, both the int fields and textual fields will be set. The textual field has the commonly
// used ISO 8601 local date format (i.e. "2018-01-01").
// When used an API input, either specify the int fields or the textual field. If both are specified, the textual
// field will be discarded.
type Date struct {
	Year    uint32 `protobuf:"varint,1,opt,name=year" json:"year,omitempty"`
	Month   uint32 `protobuf:"varint,2,opt,name=month" json:"month,omitempty"`
	Day     uint32 `protobuf:"varint,3,opt,name=day" json:"day,omitempty"`
	Textual string `protobuf:"bytes,4,opt,name=textual" json:"textual,omitempty"`
}

func (m *Date) Reset()                    { *m = Date{} }
func (m *Date) String() string            { return proto.CompactTextString(m) }
func (*Date) ProtoMessage()               {}
func (*Date) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Date) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *Date) GetMonth() uint32 {
	if m != nil {
		return m.Month
	}
	return 0
}

func (m *Date) GetDay() uint32 {
	if m != nil {
		return m.Day
	}
	return 0
}

func (m *Date) GetTextual() string {
	if m != nil {
		return m.Textual
	}
	return ""
}

// Geographic latitude and longitude coordinates specified in decimal degrees.
type Location struct {
	Latitude  float64 `protobuf:"fixed64,1,opt,name=latitude" json:"latitude,omitempty"`
	Longitude float64 `protobuf:"fixed64,2,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Location) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Location) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

// Area between two locations, normalized to bottom-left and top-right points.
// Center point is added for convenience; it's simple the point directly between the two corner points.
type Area struct {
	Center     *Location `protobuf:"bytes,1,opt,name=center" json:"center,omitempty"`
	BottomLeft *Location `protobuf:"bytes,2,opt,name=bottom_left,json=bottomLeft" json:"bottom_left,omitempty"`
	TopRight   *Location `protobuf:"bytes,4,opt,name=top_right,json=topRight" json:"top_right,omitempty"`
}

func (m *Area) Reset()                    { *m = Area{} }
func (m *Area) String() string            { return proto.CompactTextString(m) }
func (*Area) ProtoMessage()               {}
func (*Area) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Area) GetCenter() *Location {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *Area) GetBottomLeft() *Location {
	if m != nil {
		return m.BottomLeft
	}
	return nil
}

func (m *Area) GetTopRight() *Location {
	if m != nil {
		return m.TopRight
	}
	return nil
}

// Pagination is normalized across the api. Provide a pagination object to get a specific page or offset,
// or limit your data.
//
// Calls that have a pagination option automatically return a Pagination.Result, which contains
// either the specified pagination options or the defaults, as well as total counts. It also contains Pagination
// objects that can be used for the previous and next page.
//
// This effectively means that an api user would never need to create their own pagination object; as long as they
// start at the first page and continue to the next, they can use the provided Pagination object.
type Pagination struct {
	Size int32 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Page int32 `protobuf:"varint,2,opt,name=page" json:"page,omitempty"`
}

func (m *Pagination) Reset()                    { *m = Pagination{} }
func (m *Pagination) String() string            { return proto.CompactTextString(m) }
func (*Pagination) ProtoMessage()               {}
func (*Pagination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Pagination) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Pagination) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

type Pagination_Result struct {
	Size       int32       `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Page       int32       `protobuf:"varint,2,opt,name=page" json:"page,omitempty"`
	Total      int32       `protobuf:"varint,3,opt,name=total" json:"total,omitempty"`
	TotalPages int32       `protobuf:"varint,4,opt,name=total_pages,json=totalPages" json:"total_pages,omitempty"`
	Previous   *Pagination `protobuf:"bytes,6,opt,name=previous" json:"previous,omitempty"`
	Next       *Pagination `protobuf:"bytes,7,opt,name=next" json:"next,omitempty"`
}

func (m *Pagination_Result) Reset()                    { *m = Pagination_Result{} }
func (m *Pagination_Result) String() string            { return proto.CompactTextString(m) }
func (*Pagination_Result) ProtoMessage()               {}
func (*Pagination_Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *Pagination_Result) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Pagination_Result) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *Pagination_Result) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Pagination_Result) GetTotalPages() int32 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *Pagination_Result) GetPrevious() *Pagination {
	if m != nil {
		return m.Previous
	}
	return nil
}

func (m *Pagination_Result) GetNext() *Pagination {
	if m != nil {
		return m.Next
	}
	return nil
}

// Filters used in many api calls to filter the data sources, results, etc.
//
// "Include" fields filter out anything not in the include set.
// When not set, all items will be returned (except excluded items)
// "Exclude" fields filter out anything in the exclude set.
// When combined with include, exclude takes precedence when determining whether an item is filtered
type Filter struct {
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// Specify which organizations to get data from. By default, data is only retrieved for the current organization, but
// using ChildOrganizations we can specify to include a number of, or all, sub-organizations.
//
// Note: ChildOrganization differs from other filters in that it defaults to not allowing anything, where the
// other filters default to allowing everything
type Filter_ChildOrganizations struct {
	IncludeAll bool     `protobuf:"varint,1,opt,name=include_all,json=includeAll" json:"include_all,omitempty"`
	Include    []string `protobuf:"bytes,2,rep,name=include" json:"include,omitempty"`
	Exclude    []string `protobuf:"bytes,3,rep,name=exclude" json:"exclude,omitempty"`
}

func (m *Filter_ChildOrganizations) Reset()                    { *m = Filter_ChildOrganizations{} }
func (m *Filter_ChildOrganizations) String() string            { return proto.CompactTextString(m) }
func (*Filter_ChildOrganizations) ProtoMessage()               {}
func (*Filter_ChildOrganizations) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *Filter_ChildOrganizations) GetIncludeAll() bool {
	if m != nil {
		return m.IncludeAll
	}
	return false
}

func (m *Filter_ChildOrganizations) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_ChildOrganizations) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type Filter_Organizations struct {
	Include []string `protobuf:"bytes,1,rep,name=include" json:"include,omitempty"`
	Exclude []string `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
}

func (m *Filter_Organizations) Reset()                    { *m = Filter_Organizations{} }
func (m *Filter_Organizations) String() string            { return proto.CompactTextString(m) }
func (*Filter_Organizations) ProtoMessage()               {}
func (*Filter_Organizations) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1} }

func (m *Filter_Organizations) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Organizations) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type Filter_Events struct {
	Include []EventType `protobuf:"varint,1,rep,packed,name=include,enum=hiber.EventType" json:"include,omitempty"`
	Exclude []EventType `protobuf:"varint,2,rep,packed,name=exclude,enum=hiber.EventType" json:"exclude,omitempty"`
}

func (m *Filter_Events) Reset()                    { *m = Filter_Events{} }
func (m *Filter_Events) String() string            { return proto.CompactTextString(m) }
func (*Filter_Events) ProtoMessage()               {}
func (*Filter_Events) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 2} }

func (m *Filter_Events) GetInclude() []EventType {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Events) GetExclude() []EventType {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type Filter_Modems struct {
	Include []string `protobuf:"bytes,1,rep,name=include" json:"include,omitempty"`
	Exclude []string `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
}

func (m *Filter_Modems) Reset()                    { *m = Filter_Modems{} }
func (m *Filter_Modems) String() string            { return proto.CompactTextString(m) }
func (*Filter_Modems) ProtoMessage()               {}
func (*Filter_Modems) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 3} }

func (m *Filter_Modems) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Modems) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type Filter_Tags struct {
	Include []int64 `protobuf:"varint,1,rep,packed,name=include" json:"include,omitempty"`
	Exclude []int64 `protobuf:"varint,2,rep,packed,name=exclude" json:"exclude,omitempty"`
}

func (m *Filter_Tags) Reset()                    { *m = Filter_Tags{} }
func (m *Filter_Tags) String() string            { return proto.CompactTextString(m) }
func (*Filter_Tags) ProtoMessage()               {}
func (*Filter_Tags) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 4} }

func (m *Filter_Tags) GetInclude() []int64 {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Tags) GetExclude() []int64 {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type Filter_Webhooks struct {
	Include    []int64 `protobuf:"varint,1,rep,packed,name=include" json:"include,omitempty"`
	Exclude    []int64 `protobuf:"varint,2,rep,packed,name=exclude" json:"exclude,omitempty"`
	OnlyActive bool    `protobuf:"varint,3,opt,name=only_active,json=onlyActive" json:"only_active,omitempty"`
}

func (m *Filter_Webhooks) Reset()                    { *m = Filter_Webhooks{} }
func (m *Filter_Webhooks) String() string            { return proto.CompactTextString(m) }
func (*Filter_Webhooks) ProtoMessage()               {}
func (*Filter_Webhooks) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 5} }

func (m *Filter_Webhooks) GetInclude() []int64 {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Webhooks) GetExclude() []int64 {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *Filter_Webhooks) GetOnlyActive() bool {
	if m != nil {
		return m.OnlyActive
	}
	return false
}

type Filter_Users struct {
	Include []string `protobuf:"bytes,1,rep,name=include" json:"include,omitempty"`
	Exclude []string `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
}

func (m *Filter_Users) Reset()                    { *m = Filter_Users{} }
func (m *Filter_Users) String() string            { return proto.CompactTextString(m) }
func (*Filter_Users) ProtoMessage()               {}
func (*Filter_Users) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 6} }

func (m *Filter_Users) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Filter_Users) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func init() {
	proto.RegisterType((*UpdateZeroableInt)(nil), "hiber.UpdateZeroableInt")
	proto.RegisterType((*UpdateClearableString)(nil), "hiber.UpdateClearableString")
	proto.RegisterType((*UpdateBoolean)(nil), "hiber.UpdateBoolean")
	proto.RegisterType((*TimeRange)(nil), "hiber.TimeRange")
	proto.RegisterType((*Timestamp)(nil), "hiber.Timestamp")
	proto.RegisterType((*Date)(nil), "hiber.Date")
	proto.RegisterType((*Location)(nil), "hiber.Location")
	proto.RegisterType((*Area)(nil), "hiber.Area")
	proto.RegisterType((*Pagination)(nil), "hiber.Pagination")
	proto.RegisterType((*Pagination_Result)(nil), "hiber.Pagination.Result")
	proto.RegisterType((*Filter)(nil), "hiber.Filter")
	proto.RegisterType((*Filter_ChildOrganizations)(nil), "hiber.Filter.ChildOrganizations")
	proto.RegisterType((*Filter_Organizations)(nil), "hiber.Filter.Organizations")
	proto.RegisterType((*Filter_Events)(nil), "hiber.Filter.Events")
	proto.RegisterType((*Filter_Modems)(nil), "hiber.Filter.Modems")
	proto.RegisterType((*Filter_Tags)(nil), "hiber.Filter.Tags")
	proto.RegisterType((*Filter_Webhooks)(nil), "hiber.Filter.Webhooks")
	proto.RegisterType((*Filter_Users)(nil), "hiber.Filter.Users")
	proto.RegisterEnum("hiber.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("hiber.Health", Health_name, Health_value)
}

func init() { proto.RegisterFile("base.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1022 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0xef, 0x4e, 0xe3, 0xc6,
	0x17, 0xdd, 0xfc, 0x25, 0xb9, 0x59, 0xc0, 0x0c, 0xb0, 0xf8, 0x97, 0x5d, 0xfd, 0x40, 0x91, 0xba,
	0x45, 0xa8, 0xcd, 0x56, 0xed, 0x97, 0xaa, 0xad, 0x54, 0x19, 0x7b, 0x60, 0x23, 0x92, 0x38, 0x1d,
	0x3b, 0x45, 0x45, 0x95, 0xdc, 0x09, 0x19, 0x1c, 0xab, 0x13, 0x4f, 0xe4, 0x4c, 0x10, 0xec, 0x4b,
	0xf4, 0x5d, 0xfa, 0xbd, 0x0f, 0xd2, 0xf7, 0xe8, 0x03, 0x54, 0x33, 0x76, 0x12, 0xc2, 0x9f, 0x0a,
	0xf1, 0x6d, 0xee, 0x39, 0xe7, 0x9e, 0xb9, 0xf7, 0xd8, 0x56, 0x02, 0x30, 0xa0, 0x53, 0xd6, 0x9c,
	0x24, 0x42, 0x0a, 0x54, 0x1a, 0x45, 0x03, 0x96, 0xd4, 0xf7, 0x43, 0x21, 0x42, 0xce, 0x3e, 0x68,
	0x70, 0x30, 0xbb, 0xfa, 0x20, 0xa3, 0x31, 0x9b, 0x4a, 0x3a, 0x9e, 0xa4, 0xba, 0x86, 0x0d, 0x5b,
	0xfd, 0xc9, 0x90, 0x4a, 0x76, 0xc1, 0x12, 0x41, 0x07, 0x9c, 0xb5, 0x62, 0x89, 0x4c, 0x58, 0x9b,
	0x69, 0x70, 0x68, 0xe6, 0x0e, 0x72, 0x87, 0x15, 0x32, 0x2f, 0xd1, 0x0e, 0x94, 0xae, 0x29, 0x9f,
	0x31, 0x33, 0x7f, 0x90, 0x3b, 0x5c, 0x27, 0x69, 0xd1, 0x38, 0x85, 0xdd, 0xd4, 0xc4, 0xe6, 0x8c,
	0x26, 0xca, 0xc5, 0x93, 0x49, 0x14, 0x87, 0xcf, 0x35, 0xaa, 0xce, 0x8d, 0x7e, 0x84, 0xf5, 0xd4,
	0xe8, 0x58, 0x08, 0xce, 0x68, 0xfc, 0x5c, 0x83, 0xca, 0xdc, 0xe0, 0x1c, 0xaa, 0x7e, 0x34, 0x66,
	0x84, 0xc6, 0x21, 0x43, 0xef, 0xa1, 0x34, 0x95, 0x34, 0x91, 0xba, 0xb5, 0xf6, 0xb5, 0xd1, 0xd4,
	0x99, 0x34, 0xfd, 0x79, 0x04, 0x24, 0xa5, 0x51, 0x03, 0x0a, 0x2c, 0x1e, 0x6a, 0xa3, 0xc7, 0x54,
	0x8a, 0x6c, 0x04, 0xa9, 0xb1, 0x46, 0xd0, 0xb7, 0x50, 0x5d, 0xe4, 0x98, 0x99, 0xd7, 0x9b, 0x69,
	0xd2, 0xcd, 0x79, 0xd2, 0x77, 0x0c, 0x96, 0x62, 0xb5, 0x8f, 0x64, 0x37, 0x72, 0x46, 0xb9, 0x59,
	0xd4, 0x8b, 0xcf, 0xcb, 0xc6, 0xaf, 0x50, 0x74, 0xa8, 0x64, 0x08, 0x41, 0xf1, 0x96, 0xd1, 0x44,
	0xdb, 0xae, 0x13, 0x7d, 0x56, 0xbb, 0x8e, 0x45, 0x2c, 0x47, 0xf3, 0xd4, 0x75, 0x81, 0x0c, 0x28,
	0x0c, 0xe9, 0xad, 0x59, 0xd0, 0x98, 0x3a, 0xfe, 0x87, 0xbb, 0x03, 0x95, 0xb6, 0xb8, 0xa4, 0x32,
	0x12, 0x31, 0xaa, 0x43, 0x85, 0x53, 0x19, 0xc9, 0xd9, 0x90, 0xe9, 0x5b, 0x72, 0x64, 0x51, 0xa3,
	0x77, 0x50, 0xe5, 0x22, 0x0e, 0x53, 0x32, 0xaf, 0xc9, 0x25, 0xd0, 0xf8, 0x23, 0x07, 0x45, 0x2b,
	0x61, 0x14, 0x7d, 0x0e, 0xe5, 0x4b, 0x16, 0x4b, 0x96, 0x64, 0xdb, 0x6f, 0x66, 0xa1, 0xcd, 0xef,
	0x20, 0x19, 0x8d, 0xbe, 0x82, 0xda, 0x40, 0x48, 0x29, 0xc6, 0x01, 0x67, 0x57, 0x32, 0x8b, 0xf8,
	0x81, 0x1a, 0x52, 0x4d, 0x9b, 0x5d, 0x49, 0xf4, 0x05, 0x54, 0xa5, 0x98, 0x04, 0x49, 0x14, 0x8e,
	0xa4, 0xde, 0xe2, 0x11, 0x7d, 0x45, 0x8a, 0x09, 0x51, 0x82, 0xc6, 0x3f, 0x39, 0x80, 0x1e, 0x0d,
	0xa3, 0x38, 0x5d, 0x0d, 0x41, 0x71, 0x1a, 0x7d, 0x4a, 0xd7, 0x2a, 0x11, 0x7d, 0x56, 0xd8, 0x84,
	0x86, 0xe9, 0x36, 0x25, 0xa2, 0xcf, 0xf5, 0xbf, 0x72, 0x50, 0x26, 0x6c, 0x3a, 0xe3, 0xf2, 0xb9,
	0x2d, 0xea, 0x19, 0x48, 0x21, 0x29, 0xd7, 0x79, 0x97, 0x48, 0x5a, 0xa0, 0x7d, 0xa8, 0xe9, 0x43,
	0xa0, 0x34, 0x53, 0x3d, 0x6f, 0x89, 0x80, 0x86, 0x7a, 0x0a, 0x41, 0x5f, 0x42, 0x65, 0x92, 0xb0,
	0xeb, 0x48, 0xcc, 0xa6, 0x66, 0x59, 0x6f, 0xb3, 0x95, 0x6d, 0xb3, 0x1c, 0x9b, 0x2c, 0x24, 0xe8,
	0x33, 0x28, 0xc6, 0xec, 0x46, 0x9a, 0x6b, 0x4f, 0x49, 0x35, 0xdd, 0xf8, 0xb3, 0x08, 0xe5, 0x93,
	0x88, 0x4b, 0x96, 0xd4, 0x23, 0x40, 0xf6, 0x28, 0xe2, 0x43, 0x37, 0x09, 0x69, 0x1c, 0x7d, 0xd2,
	0xaa, 0xa9, 0x9a, 0x2b, 0x8a, 0x2f, 0xf9, 0x6c, 0xc8, 0x02, 0xca, 0x79, 0xf6, 0xed, 0x40, 0x06,
	0x59, 0x9c, 0xab, 0x57, 0x25, 0xab, 0xcc, 0xfc, 0x41, 0x41, 0xbd, 0x2a, 0x59, 0xa9, 0x18, 0x76,
	0x93, 0x32, 0x85, 0x94, 0xc9, 0xca, 0xba, 0x0d, 0xeb, 0xab, 0xb7, 0xdc, 0x31, 0xc9, 0x3d, 0x69,
	0x92, 0x5f, 0x35, 0xf9, 0x0d, 0xca, 0xf8, 0x9a, 0xc5, 0x72, 0x8a, 0x8e, 0x56, 0xbb, 0x37, 0x16,
	0x9f, 0x9e, 0xe6, 0xfd, 0xdb, 0x09, 0x5b, 0xfa, 0x1d, 0xad, 0xfa, 0x3d, 0xaa, 0x9d, 0xdf, 0xf0,
	0x03, 0x94, 0x3b, 0x62, 0xc8, 0xc6, 0x2f, 0x9b, 0xef, 0x3b, 0x28, 0xfa, 0x34, 0x7c, 0xd0, 0x5b,
	0x78, 0xb2, 0xb7, 0xb0, 0xec, 0x0d, 0xa0, 0x72, 0xce, 0x06, 0x23, 0x21, 0x7e, 0x7f, 0x51, 0xbf,
	0x7a, 0x6a, 0x22, 0xe6, 0xb7, 0x01, 0xbd, 0x94, 0xd1, 0x35, 0xd3, 0x6f, 0x5a, 0x85, 0x80, 0x82,
	0x2c, 0x8d, 0xd4, 0xbf, 0x87, 0x52, 0x7f, 0xca, 0x92, 0x17, 0x6d, 0x76, 0xf4, 0x77, 0x11, 0xaa,
	0x8b, 0xb8, 0x50, 0x0d, 0xd6, 0x1c, 0x7c, 0x62, 0xf5, 0xdb, 0xbe, 0xf1, 0x0a, 0x6d, 0xc3, 0xe6,
	0x39, 0x3e, 0xfe, 0xe8, 0xba, 0x67, 0x81, 0x4d, 0xb0, 0xe5, 0x63, 0xc7, 0xc8, 0xdd, 0x05, 0xfb,
	0x3d, 0x47, 0x83, 0xf9, 0xbb, 0xa0, 0x83, 0xdb, 0x58, 0x81, 0x05, 0x54, 0x87, 0x37, 0x1d, 0xd7,
	0xc1, 0x9d, 0xa0, 0xed, 0xda, 0x96, 0xdf, 0x72, 0xbb, 0x8b, 0x86, 0xe2, 0x92, 0xeb, 0x60, 0xcf,
	0xb3, 0x4e, 0x71, 0x40, 0xb0, 0x8d, 0x5b, 0x3f, 0x63, 0xc7, 0x28, 0xa1, 0x3d, 0xd8, 0xee, 0x7b,
	0x98, 0x04, 0x96, 0x6d, 0x63, 0xcf, 0x0b, 0x08, 0xfe, 0xa9, 0x8f, 0x3d, 0xdf, 0xa8, 0xa0, 0x0d,
	0x80, 0x94, 0x70, 0x1c, 0xec, 0x18, 0x55, 0x64, 0xc0, 0x6b, 0x5d, 0x13, 0xdc, 0x71, 0x55, 0x2b,
	0x20, 0x04, 0x1b, 0xf3, 0x39, 0x4e, 0xac, 0x56, 0x1b, 0x3b, 0x46, 0x0d, 0x99, 0xb0, 0xe3, 0x92,
	0x53, 0xab, 0xdb, 0xba, 0x58, 0x1d, 0xe2, 0x35, 0xda, 0x87, 0xb7, 0xab, 0x43, 0x78, 0xea, 0xaa,
	0xae, 0x8d, 0x03, 0xef, 0xac, 0xd5, 0x33, 0xd6, 0xd1, 0xff, 0x60, 0x77, 0x55, 0xe0, 0xe0, 0xb6,
	0xf5, 0x0b, 0x76, 0x8c, 0x0d, 0xd4, 0x80, 0xff, 0xaf, 0x52, 0xb6, 0xd5, 0xed, 0xba, 0x7e, 0x70,
	0x8c, 0x83, 0x9e, 0x45, 0x3c, 0xec, 0x18, 0x9b, 0x68, 0x13, 0x6a, 0xa9, 0xc6, 0xf3, 0xad, 0x36,
	0x36, 0x8c, 0xe5, 0xd6, 0x3e, 0xb1, 0xba, 0xde, 0x09, 0x26, 0x8a, 0x21, 0x6a, 0x98, 0x2d, 0xf4,
	0x16, 0xf6, 0xee, 0x71, 0x8b, 0x48, 0x10, 0x7a, 0x07, 0xe6, 0x3d, 0xd2, 0xb6, 0xba, 0x36, 0x6e,
	0xab, 0x0d, 0xb7, 0x97, 0x7b, 0x2c, 0x58, 0x35, 0xc9, 0xa2, 0x7d, 0x07, 0x1d, 0xc1, 0xfb, 0x07,
	0xde, 0x7e, 0x9f, 0x74, 0x1f, 0xce, 0xb1, 0xab, 0xd2, 0x4f, 0xb5, 0x76, 0xdb, 0x6a, 0x75, 0x16,
	0x0f, 0xfe, 0x8d, 0xca, 0xf1, 0x2e, 0xa1, 0x9e, 0x4e, 0x4f, 0x31, 0x7b, 0xf7, 0x5b, 0x08, 0x3e,
	0xe9, 0xab, 0x00, 0xcc, 0xa3, 0x43, 0x28, 0x7f, 0x64, 0x94, 0xcb, 0x11, 0x2a, 0x43, 0xde, 0x3d,
	0x33, 0x5e, 0xa9, 0xf7, 0xeb, 0xdc, 0x22, 0xdd, 0x56, 0xf7, 0xd4, 0xc8, 0xa1, 0x2a, 0x94, 0x30,
	0x21, 0x2e, 0x31, 0xf2, 0xc7, 0x07, 0xb0, 0x1b, 0x72, 0x31, 0xa0, 0x3c, 0xfb, 0x80, 0xe9, 0x24,
	0x6a, 0x86, 0xc9, 0xe4, 0xb2, 0x97, 0xbb, 0x48, 0xff, 0xb3, 0x0c, 0xca, 0xfa, 0x27, 0xf4, 0x9b,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x1a, 0x32, 0x2b, 0x0e, 0xcf, 0x08, 0x00, 0x00,
}
